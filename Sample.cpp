// CSDKGame.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <chrono>
#include <iostream>

#include "HandleInput.h"
#include "Razer\ChromaSDKPluginTypes.h"
#include "Razer\ChromaAnimationAPI.h"
#include "RazerKeyboardMapping.h"

using namespace std;
using namespace std::chrono;
using namespace ChromaSDK;

const float MATH_PI = 3.14159f;

//autogenerated

void ShowEffect1()
{
	// start with a blank animation
	const char* baseLayer = "animations/Sprite1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect2()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Keyboard.chroma";
	const char* layer2 = "animations/Rainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}









int _gSelection = 0;
const int MAX_SELECTION = 39;
int _gIndex = 0;
char _gTextBuffer[16];
char _gManualInput[] = {
	' ',
	' ',
};

const char* IsSelected()
{
	++_gIndex;
	if (_gIndex == _gSelection)
	{
		return "*";
	}
	else
	{
		memset(_gTextBuffer, 0, size(_gTextBuffer));
		sprintf_s(_gTextBuffer, "%d", _gIndex);
		return _gTextBuffer;
	}
}

void PrintLegend()
{
	for (int i = 0; i < 25; ++i)
	{
		fprintf(stdout, "\r\n");
	}

	fprintf(stdout, "Use UP and DOWN arrows to select animation and press ENTER.\r\n");
	fprintf(stdout, "\r\n");

	_gIndex = -1;

	fprintf(stdout, "[%s] Quit\r\n", IsSelected());

	int effect = 0;
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "\r\n");
	fprintf(stdout, "\r\n");
	fprintf(stdout, "[%d] Press ENTER to play selection. ", _gSelection);

	fprintf(stdout, "\r\n");
	if (_gManualInput[0] != ' ')
	{
		fprintf(stdout, "%c", _gManualInput[0]);
		if (_gManualInput[1] != ' ')
		{
			fprintf(stdout, "%c", _gManualInput[1]);
		}
		fprintf(stdout, "\r\n");
	}
}

void ClearManualInput()
{
	_gManualInput[0] = ' ';
	_gManualInput[1] = ' ';
}

bool ExecuteEffect();

int main()
{
	fprintf(stderr, "App launched!\r\n");
	if (ChromaAnimationAPI::InitAPI() != 0)
	{
		return -1;
	}

	// sample for getting the mapping between potential UI key binding enums and RZKEY
	RazerKeyboardMapping* mapping = RazerKeyboardMapping::GetInstance();
	int key = mapping->GetRZKEY(2);

	HandleInput numKeys[] =
	{
		HandleInput('0'),
		HandleInput('1'),
		HandleInput('2'),
		HandleInput('3'),
		HandleInput('4'),
		HandleInput('5'),
		HandleInput('6'),
		HandleInput('7'),
		HandleInput('8'),
		HandleInput('9'),
	};

	HandleInput numpadKeys[] =
	{
		HandleInput(VK_NUMPAD0),
		HandleInput(VK_NUMPAD1),
		HandleInput(VK_NUMPAD2),
		HandleInput(VK_NUMPAD3),
		HandleInput(VK_NUMPAD4),
		HandleInput(VK_NUMPAD5),
		HandleInput(VK_NUMPAD6),
		HandleInput(VK_NUMPAD7),
		HandleInput(VK_NUMPAD8),
		HandleInput(VK_NUMPAD9),
	};

	PrintLegend();
	HandleInput inputUp = HandleInput(VK_UP);
	HandleInput inputDown = HandleInput(VK_DOWN);
	HandleInput inputBackspace = HandleInput(VK_BACK);
	HandleInput inputEnter = HandleInput(VK_RETURN);
	while (true)
	{
		if (inputUp.WasReleased())
		{
			ClearManualInput();
			if (_gSelection > 0)
			{
				--_gSelection;
			}
			PrintLegend();
			if (_gSelection > 0)
			{
				ExecuteEffect();
			}
		}
		

		else if (inputDown.WasReleased())
		{
			ClearManualInput();
			if (_gSelection < MAX_SELECTION)
			{
				_gSelection++;
			}
			PrintLegend();
			if (_gSelection > 0)
			{
				ExecuteEffect();
			}
		}

		bool hasManualInput = false;
		if (inputBackspace.WasReleased())
		{
			if (_gManualInput[1] != ' ')
			{
				_gManualInput[1] = ' ';
				hasManualInput = true;

			}
			else if (_gManualInput[0] != ' ')
			{
				_gManualInput[0] = ' ';
				hasManualInput = true;
			}
		}
		for (int i = 0; i < (int)size(numKeys); ++i)
		{
			if (numKeys[i].WasReleased() ||
				numpadKeys[i].WasReleased())
			{
				if (_gManualInput[0] != ' ')
				{
					_gManualInput[1] = numKeys[i].GetKey();
					hasManualInput = true;
				}
				else
				{
					_gManualInput[0] = numKeys[i].GetKey();
					hasManualInput = true;
				}
			}
		}
		if (hasManualInput)
		{
			int val = 0;
			if (_gManualInput[1] != ' ')
			{
				if (_gManualInput[0] >= '0' && _gManualInput[0] <= '9')
				{
					val = 10 * (_gManualInput[0] - '0');
				}
				if (_gManualInput[1] >= '0' && _gManualInput[1] <= '9')
				{
					val += _gManualInput[1] - '0';
				}
			}
			else if (_gManualInput[0] != ' ')
			{
				val = _gManualInput[0] - '0';
			}
			if (val <= MAX_SELECTION)
			{
				_gSelection = val;
			}
			PrintLegend();
		}

		if (inputEnter.WasReleased())
		{
			PrintLegend();
			ClearManualInput();

			if (ExecuteEffect())
			{
				return 0;
			}
		}
		Sleep(1);
	}

    return 0;
}

bool ExecuteEffect()
{
	// get current time
	high_resolution_clock::time_point timer = high_resolution_clock::now();

	switch (_gSelection)
	{
	case 0:
		ChromaAnimationAPI::ClearAll();
		ChromaAnimationAPI::Uninit();
		return true;

	case 1:
		ShowEffect1();
		break;
	case 2:
		ShowEffect2();
		break;
	case 3:
		ShowEffect3();
		break;
	case 4:
		ShowEffect4();
		break;
	case 5:
		ShowEffect5();
		break;
	case 6:
		ShowEffect6();
		break;
	case 7:
		ShowEffect7();
		break;
	case 8:
		ShowEffect8();
		break;
	case 9:
		ShowEffect9();
		break;
	case 10:
		ShowEffect10();
		break;
	case 11:
		ShowEffect11();
		break;
	case 12:
		ShowEffect12();
		break;
	case 13:
		ShowEffect13();
		break;
	case 14:
		ShowEffect14();
		break;
	case 15:
		ShowEffect15();
		break;
	case 16:
		ShowEffect16();
		break;
	case 17:
		ShowEffect17();
		break;
	case 18:
		ShowEffect18();
		break;
	case 19:
		ShowEffect19();
		break;
	case 20:
		ShowEffect20();
		break;
	case 21:
		ShowEffect21();
		break;
	case 22:
		ShowEffect22();
		break;
	case 23:
		ShowEffect23();
		break;
	case 24:
		ShowEffect24();
		break;
	case 25:
		ShowEffect25();
		break;
	case 26:
		ShowEffect26();
		break;
	case 27:
		ShowEffect27();
		break;
	case 28:
		ShowEffect28();
		break;
	case 29:
		ShowEffect29();
		break;
	case 30:
		ShowEffect30();
		break;
	case 31:
		ShowEffect31();
		break;
	case 32:
		ShowEffect32();
		break;
	case 33:
		ShowEffect33();
		break;
	case 34:
		ShowEffect34();
		break;
	case 35:
		ShowEffect35();
		break;
	case 36:
		ShowEffect36();
		break;
	case 37:
		ShowEffect37();
		break;
	case 38:
		ShowEffect38();
		break;
	case 39:
		ShowEffect39();
		break;
	}

	// get time in seconds
	duration<double, milli> time_span = high_resolution_clock::now() - timer;
	float deltaTime = (float)(time_span.count() / 1000.0f);
	fprintf(stdout, "Elapsed time: %f\r\n\r\n", deltaTime);

	return false;
}
