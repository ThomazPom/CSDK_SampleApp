// CSDKGame.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <chrono>
#include <iostream>

#include "HandleInput.h"
#include "Razer\ChromaSDKPluginTypes.h"
#include "Razer\ChromaAnimationAPI.h"
#include "RazerKeyboardMapping.h"

using namespace std;
using namespace std::chrono;
using namespace ChromaSDK;

const float MATH_PI = 3.14159f;

// add a cache mechanism
map<string, string> _gCacheEffect = map<string, string>();

#pragma region Autogenerated
void ShowEffect1()
{
	const char* effectName = "ShowEffect1Keyboard";
	if (_gCacheEffect.find(effectName) == _gCacheEffect.end())
	{
		// start with a blank animation
		const char* baseLayer = "animations/Sprite1_Keyboard.chroma";
		// close the blank animation if it's already loaded, discarding any changes
		ChromaAnimationAPI::CloseAnimationName(baseLayer);
		// open the blank animation, passing a reference to the base animation when loading has completed
		ChromaAnimationAPI::GetAnimation(baseLayer);
		// play the animation on the dynamic canvas
		ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
		// cache the effect
		ChromaAnimationAPI::CopyAnimationName(baseLayer, effectName);
		_gCacheEffect[effectName] = "";
	}
	else
	{
		ChromaAnimationAPI::PlayAnimationName(effectName, true);
	}
}
void ShowEffect1ChromaLink()
{
	const char* effectName = "ShowEffect1ChromaLink";
	if (_gCacheEffect.find(effectName) == _gCacheEffect.end())
	{
		_gCacheEffect[effectName] = "";
		// start with a blank animation
		const char* baseLayer = "animations/Sprite1_ChromaLink.chroma";
		// close the blank animation if it's already loaded, discarding any changes
		ChromaAnimationAPI::CloseAnimationName(baseLayer);
		// open the blank animation, passing a reference to the base animation when loading has completed
		ChromaAnimationAPI::GetAnimation(baseLayer);
		// play the animation on the dynamic canvas
		ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
		// cache the effect
		ChromaAnimationAPI::CopyAnimationName(baseLayer, effectName);
		_gCacheEffect[effectName] = "";
	}
	else
	{
		ChromaAnimationAPI::PlayAnimationName(effectName, true);
	}
}
void ShowEffect1Headset()
{
	const char* effectName = "ShowEffect1Headset";
	if (_gCacheEffect.find(effectName) == _gCacheEffect.end())
	{
		_gCacheEffect[effectName] = "";
		// start with a blank animation
		const char* baseLayer = "animations/Sprite1_Headset.chroma";
		// close the blank animation if it's already loaded, discarding any changes
		ChromaAnimationAPI::CloseAnimationName(baseLayer);
		// open the blank animation, passing a reference to the base animation when loading has completed
		ChromaAnimationAPI::GetAnimation(baseLayer);
		// play the animation on the dynamic canvas
		ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
		// cache the effect
		ChromaAnimationAPI::CopyAnimationName(baseLayer, effectName);
		_gCacheEffect[effectName] = "";
	}
	else
	{
		ChromaAnimationAPI::PlayAnimationName(effectName, true);
	}
}
void ShowEffect1Mousepad()
{
	const char* effectName = "ShowEffect1Mousepad";
	if (_gCacheEffect.find(effectName) == _gCacheEffect.end())
	{
		_gCacheEffect[effectName] = "";
		// start with a blank animation
		const char* baseLayer = "animations/Sprite1_Mousepad.chroma";
		// close the blank animation if it's already loaded, discarding any changes
		ChromaAnimationAPI::CloseAnimationName(baseLayer);
		// open the blank animation, passing a reference to the base animation when loading has completed
		ChromaAnimationAPI::GetAnimation(baseLayer);
		// play the animation on the dynamic canvas
		ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
		// cache the effect
		ChromaAnimationAPI::CopyAnimationName(baseLayer, effectName);
		_gCacheEffect[effectName] = "";
	}
	else
	{
		ChromaAnimationAPI::PlayAnimationName(effectName, true);
	}
}
void ShowEffect1Mouse()
{
	const char* effectName = "ShowEffect1Mouse";
	if (_gCacheEffect.find(effectName) == _gCacheEffect.end())
	{
		_gCacheEffect[effectName] = "";
		// start with a blank animation
		const char* baseLayer = "animations/Sprite1_Mouse.chroma";
		// close the blank animation if it's already loaded, discarding any changes
		ChromaAnimationAPI::CloseAnimationName(baseLayer);
		// open the blank animation, passing a reference to the base animation when loading has completed
		ChromaAnimationAPI::GetAnimation(baseLayer);
		// play the animation on the dynamic canvas
		ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
		// cache the effect
		ChromaAnimationAPI::CopyAnimationName(baseLayer, effectName);
		_gCacheEffect[effectName] = "";
	}
	else
	{
		ChromaAnimationAPI::PlayAnimationName(effectName, true);
	}
}
void ShowEffect2()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect2ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect2Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect2Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect2Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect3Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set middle color green
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 0);
	int minThreshold = 50; //set outer color to red
	int maxThreshold = 150; //set main color to blue
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 255, 0, 0, maxThreshold, 0, 0, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect4Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect5Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/OutParticle1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// turn grayscale particles to blue water
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect6Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect7Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect8Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	// fade the start of the animation starting at frame zero to 40
	ChromaAnimationAPI::FadeStartFramesName(baseLayer, 40);
	// fade the end of the animation starting at frame length - 40 (60)
	ChromaAnimationAPI::FadeEndFramesName(baseLayer, 40);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect9Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// the length of the animation
	int frameCount = 50;
	// set all frames to white, with all frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.033, 255, 255, 255);
	//integer number of times to blink during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve, subtracting from one inverts the curve
		float t = 1 - fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// multiply the frame by the 't' intensity
		ChromaAnimationAPI::MultiplyIntensityName(baseLayer, frameId, t);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect10Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect11Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Clouds1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce the intensity of the layer
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(baseLayer, 0.25);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect12Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect13Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityRGBName(baseLayer, frameId, 255, 255, 0); //yellow
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect14Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(baseLayer, 0, 255, 255); //cyan
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect15Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/BlackAndWhiteRainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	int color1 = ChromaAnimationAPI::GetRGB(255, 0, 0); //red
	int color2 = ChromaAnimationAPI::GetRGB(0, 255, 0); //green
	//integer number of times to transition during animation
	int speed = 2;
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		//Math.cos gives a smooth 1 to 0 to 1 curve
		float t = fabsf(cos(speed * MATH_PI * (frameId + 1) / (float)frameCount));
		// use t to transition from color 1 to color 2
		int color = ChromaAnimationAPI::LerpColor(color1, color2, t);
		// give color to the layer
		ChromaAnimationAPI::MultiplyIntensityColorName(baseLayer, frameId, color);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect16Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect17Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(baseLayer);
	// loop over all frames in the layer
	for (int frameId = 0; frameId < frameCount; ++frameId) {
		int threshold = 100;
		// give color to the layer
		ChromaAnimationAPI::FillThresholdColorsRGBName(baseLayer, frameId, threshold, 255, 0, 0);
	}
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect18Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int threshold = 50;
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(baseLayer, threshold, 0, 64, 0); //dark green
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect19Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Tongue1_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int minThreshold = 50; //dark cyan
	int maxThreshold = 150; //purple
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 63, 63, maxThreshold, 127, 0, 127);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect20Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Arc3_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	const char* layer2 = "Animations/Arc3_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	const char* layer2 = "Animations/Arc3_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	const char* layer2 = "Animations/Arc3_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect21Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	const char* layer2 = "Animations/Arc3_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	const char* layer2 = "Animations/Arc3_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	const char* layer2 = "Animations/Arc3_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	const char* layer2 = "Animations/Arc3_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect22Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	const char* layer2 = "Animations/Arc3_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// replace darker colors with background color
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(layer2, 64, background);
	// copy non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	const char* layer2 = "Animations/Arc3_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	const char* layer2 = "Animations/Arc3_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	const char* layer2 = "Animations/Arc3_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect23Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	const char* layer2 = "Animations/Arc3_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* layer2 = "Animations/Arc3_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	const char* layer2 = "Animations/Arc3_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	const char* layer2 = "Animations/Arc3_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	const char* layer2 = "Animations/Arc3_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect24Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	const char* layer2 = "Animations/Arc3_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	// setup background color on the base layer
	int background = ChromaAnimationAPI::GetRGB(127, 0, 0);
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, background);
	// Add non zero colors from layer 2 to the base layer
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(layer2, baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Keyboard.chroma";
	const char* layer2 = "animations/Rainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_ChromaLink.chroma";
	const char* layer2 = "animations/Rainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Headset.chroma";
	const char* layer2 = "animations/Rainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Mousepad.chroma";
	const char* layer2 = "animations/Rainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect25Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Mouse.chroma";
	const char* layer2 = "animations/Rainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(layer2);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	ChromaAnimationAPI::GetAnimation(layer2);
	int frameCount = ChromaAnimationAPI::GetFrameCountName(layer2);
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// copy non zero colors from layer 2 to the base layer where the base layer was non zero
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(layer2, baseLayer);
	// set a background color
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(baseLayer, 255, 0, 0);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect26Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect27Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect28Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reverse the order of frames
	ChromaAnimationAPI::ReverseAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect29Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// invert all the animation colors
	ChromaAnimationAPI::InvertColorsAllFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect30Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// duplicate and mirror
	ChromaAnimationAPI::DuplicateMirrorFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect31Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// insert a pause
	int frameId = 50;
	int delay = 20;
	ChromaAnimationAPI::InsertDelayName(baseLayer, frameId, delay);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect32Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// reduce half of the frames, remove every 2nd frame
	ChromaAnimationAPI::ReduceFramesName(baseLayer, 2);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect33Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// double the number of the frames
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect34Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect35Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/MovementUpLeft_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// trim the start of the animation, so it starts at frame 10
	ChromaAnimationAPI::TrimStartFramesName(baseLayer, 10);
	// trim the end of the animation
	ChromaAnimationAPI::TrimEndFramesName(baseLayer, 75);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect36Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/CircleSmall_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	ChromaAnimationAPI::DuplicateFirstFrameName(baseLayer, frameCount);
	// set animation playback to 30 FPS
	ChromaAnimationAPI::OverrideFrameDurationName(baseLayer, 0.033f);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect37Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect38Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	// make random colors more sparse using threshold
	int threshold = 240;
	// turn lower intensity colors to black
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(baseLayer, threshold, 0);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect39Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	int frameCount = 20;
	// Start with blank frames set to 30FPS
	ChromaAnimationAPI::MakeBlankFramesName(baseLayer, frameCount, 0.033, 0);
	// Fill all frames with black and white static
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(baseLayer);
	// slow down the random frames so it can be seen
	ChromaAnimationAPI::DuplicateFramesName(baseLayer);
	int minThreshold = 240; //black
	int maxThreshold = 240; //rain
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(baseLayer, minThreshold, 0, 0, 0, maxThreshold, 0, 127, 255);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, true);
}
void ShowEffect40()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Keyboard.chroma";
	const char* idleAnimation = "Animations/BlackAndWhiteRainbow_Keyboard.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(idleAnimation);
	// Set idle animation
	ChromaAnimationAPI::SetIdleAnimationName(idleAnimation);
	// Enable idle animation
	ChromaAnimationAPI::UseIdleAnimation((int)EChromaSDKDeviceEnum::DE_Keyboard, true);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// Transition from green to red and then stop
	int frameCount = 30;
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.1f, 255, 255, 255);
	int color1 = ChromaAnimationAPI::GetRGB(0, 255, 0);
	int color2 = ChromaAnimationAPI::GetRGB(255, 0, 0);
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(baseLayer, color1, color2);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, false);
}
void ShowEffect40ChromaLink()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_ChromaLink.chroma";
	const char* idleAnimation = "Animations/BlackAndWhiteRainbow_ChromaLink.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(idleAnimation);
	// Set idle animation
	ChromaAnimationAPI::SetIdleAnimationName(idleAnimation);
	// Enable idle animation
	ChromaAnimationAPI::UseIdleAnimation((int)EChromaSDKDeviceEnum::DE_ChromaLink, true);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// Transition from green to red and then stop
	int frameCount = 30;
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.1f, 255, 255, 255);
	int color1 = ChromaAnimationAPI::GetRGB(0, 255, 0);
	int color2 = ChromaAnimationAPI::GetRGB(255, 0, 0);
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(baseLayer, color1, color2);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, false);
}
void ShowEffect40Headset()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Headset.chroma";
	const char* idleAnimation = "Animations/BlackAndWhiteRainbow_Headset.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(idleAnimation);
	// Set idle animation
	ChromaAnimationAPI::SetIdleAnimationName(idleAnimation);
	// Enable idle animation
	ChromaAnimationAPI::UseIdleAnimation((int)EChromaSDKDeviceEnum::DE_Headset, true);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// Transition from green to red and then stop
	int frameCount = 30;
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.1f, 255, 255, 255);
	int color1 = ChromaAnimationAPI::GetRGB(0, 255, 0);
	int color2 = ChromaAnimationAPI::GetRGB(255, 0, 0);
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(baseLayer, color1, color2);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, false);
}
void ShowEffect40Mousepad()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mousepad.chroma";
	const char* idleAnimation = "Animations/BlackAndWhiteRainbow_Mousepad.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(idleAnimation);
	// Set idle animation
	ChromaAnimationAPI::SetIdleAnimationName(idleAnimation);
	// Enable idle animation
	ChromaAnimationAPI::UseIdleAnimation((int)EChromaSDKDeviceEnum::DE_Mousepad, true);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// Transition from green to red and then stop
	int frameCount = 30;
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.1f, 255, 255, 255);
	int color1 = ChromaAnimationAPI::GetRGB(0, 255, 0);
	int color2 = ChromaAnimationAPI::GetRGB(255, 0, 0);
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(baseLayer, color1, color2);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, false);
}
void ShowEffect40Mouse()
{
	// start with a blank animation
	const char* baseLayer = "Animations/Blank_Mouse.chroma";
	const char* idleAnimation = "Animations/BlackAndWhiteRainbow_Mouse.chroma";
	// close the blank animation if it's already loaded, discarding any changes
	ChromaAnimationAPI::CloseAnimationName(baseLayer);
	ChromaAnimationAPI::CloseAnimationName(idleAnimation);
	// Set idle animation
	ChromaAnimationAPI::SetIdleAnimationName(idleAnimation);
	// Enable idle animation
	ChromaAnimationAPI::UseIdleAnimation((int)EChromaSDKDeviceEnum::DE_Mouse, true);
	// open the blank animation, passing a reference to the base animation when loading has completed
	ChromaAnimationAPI::GetAnimation(baseLayer);
	// Transition from green to red and then stop
	int frameCount = 30;
	ChromaAnimationAPI::MakeBlankFramesRGBName(baseLayer, frameCount, 0.1f, 255, 255, 255);
	int color1 = ChromaAnimationAPI::GetRGB(0, 255, 0);
	int color2 = ChromaAnimationAPI::GetRGB(255, 0, 0);
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(baseLayer, color1, color2);
	// play the animation on the dynamic canvas
	ChromaAnimationAPI::PlayAnimationName(baseLayer, false);
}
#pragma endregion




int _gSelection = 0;
const int MAX_SELECTION = 40;
int _gIndex = 0;
char _gTextBuffer[16];
char _gManualInput[] = {
	' ',
	' ',
};

const char* IsSelected()
{
	++_gIndex;
	if (_gIndex == _gSelection)
	{
		return "*";
	}
	else
	{
		memset(_gTextBuffer, 0, size(_gTextBuffer));
		sprintf_s(_gTextBuffer, "%d", _gIndex);
		return _gTextBuffer;
	}
}

void PrintLegend()
{
	for (int i = 0; i < 25; ++i)
	{
		fprintf(stdout, "\r\n");
	}

	fprintf(stdout, "CSDK SAMPLE APP\r\n");
	fprintf(stdout, "\r\n");

	fprintf(stdout, "Use UP and DOWN arrows to select animation and press ENTER.\r\n");
	fprintf(stdout, "\r\n");

	_gIndex = -1;

	fprintf(stdout, "[%s] Quit\r\n", IsSelected());

	int effect = 0;
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\t\t", IsSelected(), ++effect);
	fprintf(stdout, "[%s] Effect %d\r\n", IsSelected(), ++effect);

	fprintf(stdout, "\r\n");
	fprintf(stdout, "\r\n");
	fprintf(stdout, "[%d] Press ENTER to play selection. ", _gSelection);

	fprintf(stdout, "\r\n");
	if (_gManualInput[0] != ' ')
	{
		fprintf(stdout, "%c", _gManualInput[0]);
		if (_gManualInput[1] != ' ')
		{
			fprintf(stdout, "%c", _gManualInput[1]);
		}
		fprintf(stdout, "\r\n");
	}
}

void ClearManualInput()
{
	_gManualInput[0] = ' ';
	_gManualInput[1] = ' ';
}

bool ExecuteEffect();

int main()
{
	fprintf(stderr, "App launched!\r\n");
	if (ChromaAnimationAPI::InitAPI() != 0)
	{
		return -1;
	}

	// sample for getting the mapping between potential UI key binding enums and RZKEY
	RazerKeyboardMapping* mapping = RazerKeyboardMapping::GetInstance();
	int key = mapping->GetRZKEY(2);

	HandleInput numKeys[] =
	{
		HandleInput('0'),
		HandleInput('1'),
		HandleInput('2'),
		HandleInput('3'),
		HandleInput('4'),
		HandleInput('5'),
		HandleInput('6'),
		HandleInput('7'),
		HandleInput('8'),
		HandleInput('9'),
	};

	HandleInput numpadKeys[] =
	{
		HandleInput(VK_NUMPAD0),
		HandleInput(VK_NUMPAD1),
		HandleInput(VK_NUMPAD2),
		HandleInput(VK_NUMPAD3),
		HandleInput(VK_NUMPAD4),
		HandleInput(VK_NUMPAD5),
		HandleInput(VK_NUMPAD6),
		HandleInput(VK_NUMPAD7),
		HandleInput(VK_NUMPAD8),
		HandleInput(VK_NUMPAD9),
	};

	PrintLegend();
	HandleInput inputUp = HandleInput(VK_UP);
	HandleInput inputDown = HandleInput(VK_DOWN);
	HandleInput inputBackspace = HandleInput(VK_BACK);
	HandleInput inputEnter = HandleInput(VK_RETURN);
	while (true)
	{
		if (inputUp.WasReleased())
		{
			ClearManualInput();
			if (_gSelection > 0)
			{
				--_gSelection;
			}
			PrintLegend();
			if (_gSelection > 0)
			{
				ExecuteEffect();
			}
		}
		

		else if (inputDown.WasReleased())
		{
			ClearManualInput();
			if (_gSelection < MAX_SELECTION)
			{
				_gSelection++;
			}
			PrintLegend();
			if (_gSelection > 0)
			{
				ExecuteEffect();
			}
		}

		bool hasManualInput = false;
		if (inputBackspace.WasReleased())
		{
			if (_gManualInput[1] != ' ')
			{
				_gManualInput[1] = ' ';
				hasManualInput = true;

			}
			else if (_gManualInput[0] != ' ')
			{
				_gManualInput[0] = ' ';
				hasManualInput = true;
			}
		}
		for (int i = 0; i < (int)size(numKeys); ++i)
		{
			if (numKeys[i].WasReleased() ||
				numpadKeys[i].WasReleased())
			{
				if (_gManualInput[0] != ' ')
				{
					_gManualInput[1] = numKeys[i].GetKey();
					hasManualInput = true;
				}
				else
				{
					_gManualInput[0] = numKeys[i].GetKey();
					hasManualInput = true;
				}
			}
		}
		if (hasManualInput)
		{
			int val = 0;
			if (_gManualInput[1] != ' ')
			{
				if (_gManualInput[0] >= '0' && _gManualInput[0] <= '9')
				{
					val = 10 * (_gManualInput[0] - '0');
				}
				if (_gManualInput[1] >= '0' && _gManualInput[1] <= '9')
				{
					val += _gManualInput[1] - '0';
				}
			}
			else if (_gManualInput[0] != ' ')
			{
				val = _gManualInput[0] - '0';
			}
			if (val <= MAX_SELECTION)
			{
				_gSelection = val;
			}
			PrintLegend();
		}

		if (inputEnter.WasReleased())
		{
			PrintLegend();
			ClearManualInput();

			if (ExecuteEffect())
			{
				return 0;
			}
		}
		Sleep(1);
	}

    return 0;
}

bool ExecuteEffect()
{
	// get current time
	high_resolution_clock::time_point timer = high_resolution_clock::now();

	switch (_gSelection)
	{
	case 0:
		ChromaAnimationAPI::StopAll();
		ChromaAnimationAPI::CloseAll();
		ChromaAnimationAPI::ClearAll();
		ChromaAnimationAPI::Uninit();
		return true;

	case 1:
		ShowEffect1();
		ShowEffect1ChromaLink();
		ShowEffect1Headset();
		ShowEffect1Mousepad();
		ShowEffect1Mouse();
		break;
	case 2:
		ShowEffect2();
		ShowEffect2ChromaLink();
		ShowEffect2Headset();
		ShowEffect2Mousepad();
		ShowEffect2Mouse();
		break;
	case 3:
		ShowEffect3();
		ShowEffect3ChromaLink();
		ShowEffect3Headset();
		ShowEffect3Mousepad();
		ShowEffect3Mouse();
		break;
	case 4:
		ShowEffect4();
		ShowEffect4ChromaLink();
		ShowEffect4Headset();
		ShowEffect4Mousepad();
		ShowEffect4Mouse();
		break;
	case 5:
		ShowEffect5();
		ShowEffect5ChromaLink();
		ShowEffect5Headset();
		ShowEffect5Mousepad();
		ShowEffect5Mouse();
		break;
	case 6:
		ShowEffect6();
		ShowEffect6ChromaLink();
		ShowEffect6Headset();
		ShowEffect6Mousepad();
		ShowEffect6Mouse();
		break;
	case 7:
		ShowEffect7();
		ShowEffect7ChromaLink();
		ShowEffect7Headset();
		ShowEffect7Mousepad();
		ShowEffect7Mouse();
		break;
	case 8:
		ShowEffect8();
		ShowEffect8ChromaLink();
		ShowEffect8Headset();
		ShowEffect8Mousepad();
		ShowEffect8Mouse();
		break;
	case 9:
		ShowEffect9();
		ShowEffect9ChromaLink();
		ShowEffect9Headset();
		ShowEffect9Mousepad();
		ShowEffect9Mouse();
		break;
	case 10:
		ShowEffect10();
		ShowEffect10ChromaLink();
		ShowEffect10Headset();
		ShowEffect10Mousepad();
		ShowEffect10Mouse();
		break;
	case 11:
		ShowEffect11();
		ShowEffect11ChromaLink();
		ShowEffect11Headset();
		ShowEffect11Mousepad();
		ShowEffect11Mouse();
		break;
	case 12:
		ShowEffect12();
		ShowEffect12ChromaLink();
		ShowEffect12Headset();
		ShowEffect12Mousepad();
		ShowEffect12Mouse();
		break;
	case 13:
		ShowEffect13();
		ShowEffect13ChromaLink();
		ShowEffect13Headset();
		ShowEffect13Mousepad();
		ShowEffect13Mouse();
		break;
	case 14:
		ShowEffect14();
		ShowEffect14ChromaLink();
		ShowEffect14Headset();
		ShowEffect14Mousepad();
		ShowEffect14Mouse();
		break;
	case 15:
		ShowEffect15();
		ShowEffect15ChromaLink();
		ShowEffect15Headset();
		ShowEffect15Mousepad();
		ShowEffect15Mouse();
		break;
	case 16:
		ShowEffect16();
		ShowEffect16ChromaLink();
		ShowEffect16Headset();
		ShowEffect16Mousepad();
		ShowEffect16Mouse();
		break;
	case 17:
		ShowEffect17();
		ShowEffect17ChromaLink();
		ShowEffect17Headset();
		ShowEffect17Mousepad();
		ShowEffect17Mouse();
		break;
	case 18:
		ShowEffect18();
		ShowEffect18ChromaLink();
		ShowEffect18Headset();
		ShowEffect18Mousepad();
		ShowEffect18Mouse();
		break;
	case 19:
		ShowEffect19();
		ShowEffect19ChromaLink();
		ShowEffect19Headset();
		ShowEffect19Mousepad();
		ShowEffect19Mouse();
		break;
	case 20:
		ShowEffect20();
		ShowEffect20ChromaLink();
		ShowEffect20Headset();
		ShowEffect20Mousepad();
		ShowEffect20Mouse();
		break;
	case 21:
		ShowEffect21();
		ShowEffect21ChromaLink();
		ShowEffect21Headset();
		ShowEffect21Mousepad();
		ShowEffect21Mouse();
		break;
	case 22:
		ShowEffect22();
		ShowEffect22ChromaLink();
		ShowEffect22Headset();
		ShowEffect22Mousepad();
		ShowEffect22Mouse();
		break;
	case 23:
		ShowEffect23();
		ShowEffect23ChromaLink();
		ShowEffect23Headset();
		ShowEffect23Mousepad();
		ShowEffect23Mouse();
		break;
	case 24:
		ShowEffect24();
		ShowEffect24ChromaLink();
		ShowEffect24Headset();
		ShowEffect24Mousepad();
		ShowEffect24Mouse();
		break;
	case 25:
		ShowEffect25();
		ShowEffect25ChromaLink();
		ShowEffect25Headset();
		ShowEffect25Mousepad();
		ShowEffect25Mouse();
		break;
	case 26:
		ShowEffect26();
		ShowEffect26ChromaLink();
		ShowEffect26Headset();
		ShowEffect26Mousepad();
		ShowEffect26Mouse();
		break;
	case 27:
		ShowEffect27();
		ShowEffect27ChromaLink();
		ShowEffect27Headset();
		ShowEffect27Mousepad();
		ShowEffect27Mouse();
		break;
	case 28:
		ShowEffect28();
		ShowEffect28ChromaLink();
		ShowEffect28Headset();
		ShowEffect28Mousepad();
		ShowEffect28Mouse();
		break;
	case 29:
		ShowEffect29();
		ShowEffect29ChromaLink();
		ShowEffect29Headset();
		ShowEffect29Mousepad();
		ShowEffect29Mouse();
		break;
	case 30:
		ShowEffect30();
		ShowEffect30ChromaLink();
		ShowEffect30Headset();
		ShowEffect30Mousepad();
		ShowEffect30Mouse();
		break;
	case 31:
		ShowEffect31();
		ShowEffect31ChromaLink();
		ShowEffect31Headset();
		ShowEffect31Mousepad();
		ShowEffect31Mouse();
		break;
	case 32:
		ShowEffect32();
		ShowEffect32ChromaLink();
		ShowEffect32Headset();
		ShowEffect32Mousepad();
		ShowEffect32Mouse();
		break;
	case 33:
		ShowEffect33();
		ShowEffect33ChromaLink();
		ShowEffect33Headset();
		ShowEffect33Mousepad();
		ShowEffect33Mouse();
		break;
	case 34:
		ShowEffect34();
		ShowEffect34ChromaLink();
		ShowEffect34Headset();
		ShowEffect34Mousepad();
		ShowEffect34Mouse();
		break;
	case 35:
		ShowEffect35();
		ShowEffect35ChromaLink();
		ShowEffect35Headset();
		ShowEffect35Mousepad();
		ShowEffect35Mouse();
		break;
	case 36:
		ShowEffect36();
		ShowEffect36ChromaLink();
		ShowEffect36Headset();
		ShowEffect36Mousepad();
		ShowEffect36Mouse();
		break;
	case 37:
		ShowEffect37();
		ShowEffect37ChromaLink();
		ShowEffect37Headset();
		ShowEffect37Mousepad();
		ShowEffect37Mouse();
		break;
	case 38:
		ShowEffect38();
		ShowEffect38ChromaLink();
		ShowEffect38Headset();
		ShowEffect38Mousepad();
		ShowEffect38Mouse();
		break;
	case 39:
		ShowEffect39();
		ShowEffect39ChromaLink();
		ShowEffect39Headset();
		ShowEffect39Mousepad();
		ShowEffect39Mouse();
		break;
	case 40:
		ShowEffect40();
		ShowEffect40ChromaLink();
		ShowEffect40Headset();
		ShowEffect40Mousepad();
		ShowEffect40Mouse();
		break;
	}

	// get time in seconds
	duration<double, milli> time_span = high_resolution_clock::now() - timer;
	float deltaTime = (float)(time_span.count() / 1000.0f);
	fprintf(stdout, "Elapsed time: %f\r\n\r\n", deltaTime);

	return false;
}
